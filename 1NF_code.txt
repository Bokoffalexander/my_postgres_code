Нормализация баз данных.
Принципы нормализации описывают, как надо правильно проектировать таблицы для хранения данных. Обычно достаточно, чтобы БД находилась в третьей нормальной форме (3NF).

Большинство требований направлено на борьбу с дублированием данных, чтобы информация (например, email или имя пользователя) хранилась только в одном экземпляре.

Опишем простыми словами формы нормализации и приведем примеры ошибок проектирования БД:
1NF
Требования:

В первой нормальной форме все значения в ячейках (их в теории называют атрибуты) должны быть атомарными, то есть содержать ровно одно неделимое значение, а не список из нескольких значений.
Требуется хранить в одной ячейке таблицы одно неделимое значение. Вот пример таблицы сотрудников компании employees, где это правило нарушается. В одной колонке хранится и имя сотрудника, и его должность:

id	employee
1	Иванов И.И., директор
2	Петров П.П., менеджер
3	Сидоров С.С.,менеджер

Из-за этого нам нелегко, например, найти всех менеджеров, или выбрать только фамилии без должностей. Также, непросто написать запрос для изменения должности сотрудника, например, с "менеджер" на "старший менеджер". Для решения проблемы необходимо вынести должность в отдельную колонку. Также, возможно, имеет смысл разбить ФИО на 3 отдельных колонки, но это зависит от того, как они будут использоваться - всегда вместе или по отдельности.

Вот другой пример нарушения 1NF. Допустим, у нас есть блог и к каждому посту можно добавить теги (темы, к которым относится пост). Разработчик не соблюдает принцип атомарности в таблице posts и хранит в одной ячейке все теги сразу:

id	title	tags
1	Основы PHP	PHP, программирование
2	Мой кот	кот, личное
3	Циклы в PHP	PHP, циклы

Имеем такие недостатки: название тега не может содержать в себе запятую. Неудобно искать посты по тегу. Чтобы добавить или убрать тег, надо сначала выбрать полный список тегов, отредактировать его и сохранить обратно и это нелегко сделать одним запросом. Если мы захотим переименовать тег, то придется делать поиск и замену по всей таблице (и есть риск, что вместе с заменой тега "PHP" мы заменим и тег "уроки PHP"). Трудно вывести список тегов и число постов по каждому. Нельзя добавить тегу какие-то свойства (например, цвет или ссылку).

Для исправления проблемы теги необходимо сделать отдельной сущностью. Для этого нужно сделать отдельную таблицу tags для них:

id	name
1	PHP
2	программирование
3	кот
4	личное
5	циклы

И таблицу связи постов с тегами (многие-ко-многим) posts_to_tags, состоящую из 2 колонок tag_id и post_id. Первичным ключом в ней будет эта пара колонок (это заодно не позволит поставить посту 2 одинаковых тега, так как значения первичного ключа должны быть уникальны).

Мы заменили одну таблицу на три, но зато теперь с ними стало проще работать. Попробуй написать SQL-запросы для добавления тега к посту, удаления, переименования и увидишь разницу.

CREATE TABLE myposts (
Id SERIAL PRIMARY KEY, 
PostName CHARACTER VARYING(30)
);

CREATE TABLE tags (
Id SERIAL PRIMARY KEY, 
TagName CHARACTER VARYING(30)
);

CREATE TABLE posts_to_tags (
tag_id INTEGER,
post_id INTEGER,
PRIMARY KEY (tag_id, post_id)
);

INSERT INTO myposts VALUES (1,'Basics of php');
INSERT INTO myposts VALUES (2,'My cat');
INSERT INTO myposts VALUES (3,'Loops in php');

INSERT INTO tags VALUES (1,'php');
INSERT INTO tags VALUES (2,'programming');
INSERT INTO tags VALUES (3,' cat');
INSERT INTO tags VALUES (4,'personal');
INSERT INTO tags VALUES (5,'loops');

INSERT INTO posts_to_tags VALUES (1,1);
INSERT INTO posts_to_tags VALUES (2,1);
INSERT INTO posts_to_tags VALUES (3,2);
INSERT INTO posts_to_tags VALUES (4,2);
INSERT INTO posts_to_tags VALUES (1,3);
INSERT INTO posts_to_tags VALUES (5,3);

********************
posts=# select * from myposts ;
 id |   postname
----+---------------
  1 | Basics of php
  2 | My cat
  3 | Loops in php


posts=# select * from tags ;
 id |   tagname
----+-------------
  1 | php
  2 | programming
  3 |  cat
  4 | personal
  5 | loops


posts=# select * from posts_to_tags ;
 tag_id | post_id
--------+---------
      1 |       1
      2 |       1
      3 |       2
      4 |       2
      1 |       3
      5 |       3
********************
Запрос и подрапрос:
select TagName from tags where id in (select tag_id from posts_to_tags where post_id=1);

